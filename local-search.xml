<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode</title>
    <link href="/2024/08/31/LeetCode/"/>
    <url>/2024/08/31/LeetCode/</url>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="题目介绍："><a href="#题目介绍：" class="headerlink" title="题目介绍："></a>题目介绍：</h3><blockquote><p>输入：nums&#x3D;{2,7,11,15} , target&#x3D;22</p><p>输出：1,3</p><p>解释：因为num[1]+num[3]&#x3D;&#x3D;22 , 所以返回1,3</p></blockquote><h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><h3 id="完整代码展示"><a href="#完整代码展示" class="headerlink" title="完整代码展示"></a>完整代码展示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> target)<br>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)<br>&#123;<br><span class="hljs-keyword">return</span>&#123; i,j &#125;;<br>&#125;<br><br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//问题在于if else这种写法中没有写全，比如只写了if后返回XXX。没写if不成功情况下返回XXX。虽然我们看没问题，但是编译器比较严谨，加上就好了。比如下面代码块行是指失败时候返回空容器。返回一个空容器就没问题了。</span><br>        <span class="hljs-comment">//这两句代码使用了C++11引入的列表初始化语法：它允许你直接在返回语句中初始化一个对象。</span><br>        <span class="hljs-comment">//例如：return&#123;i，j&#125;；中就创建一个临时vector对象，并用i和j作为它的初始化元素。即，在C++11中，当你使用花括号&#123;&#125;包围一系列值时，并且这些值被用于需要特定类型对象的上下文中（比如函数的返回类型），编译器会自动进行类型推导和对象初始化。</span><br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;nums = &#123; <span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">22</span>;<br><br>Solution find;<span class="hljs-comment">//类的对象</span><br>vector&lt;<span class="hljs-type">int</span>&gt;result=find.<span class="hljs-built_in">twoSum</span>(nums, target);<br><br><span class="hljs-keyword">if</span> (!result.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;目标值&quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot;是下标为&quot;</span><br>&lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;和&quot;</span> &lt;&lt; result[<span class="hljs-number">1</span>] <br>&lt;&lt; <span class="hljs-string">&quot;对应的值之和&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有两数之和是&quot;</span> &lt;&lt; target &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br>        <br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h3 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h3><h3 id="完整代码展示-1"><a href="#完整代码展示-1" class="headerlink" title="完整代码展示"></a>完整代码展示</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一"></p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png" alt="过程二"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-comment">//与vector同样unordered_map也是C++标准模板库的一个头文件。</span><br><span class="hljs-comment">//vector定义了一个序列容器,unordered_map定义了一个 关联容器。</span><br><span class="hljs-comment">//本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。</span><br><span class="hljs-comment">//map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> target)<br>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;hashtable;<br>        <span class="hljs-comment">//unorder_map存储的元素是键值对(key-value pairs),其中每一个键都是唯一的，并且映射到一个值。因此unordered_map&lt;int, int&gt;hashtable;创建了一个unorder_map&lt;int,int&gt;类型的关联容器hashtable，用以存储数组nums中的元素值作为键(key),以及这些元素在数组中的索引作为值(value)。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>&#123;<br><span class="hljs-keyword">auto</span> it = hashtable.<span class="hljs-built_in">find</span>(target - nums[i]);<br><span class="hljs-keyword">if</span> (it != hashtable.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">return</span> &#123; it-&gt;second,i &#125;;<br>&#125;<br><span class="hljs-comment">//hashtable[nums[i]] = i;这是一种写法</span><br>            hashtable.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            <span class="hljs-comment">//这行代码是在向一个名为hashtable的unorder_map容器中添加或 更新一个键值对。</span><br>            <span class="hljs-comment">//键：nums[i]，是正在遍历的nums数组中的元素。</span><br>            <span class="hljs-comment">//值：i，是该元素在nums数组中的索引。</span><br>            <span class="hljs-comment">//如果hashtable中不存在键等于nums[i]，那么一个新的键值对将被添加到hashtable中，键为nums[i],值为i。</span><br>            <span class="hljs-comment">//如果hashtable中已经存在一个键等于nums[i]，那么它相关联的值将被更新为当前的i</span><br>&#125;<br><span class="hljs-keyword">return</span>&#123;&#125;;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;nums = &#123; <span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">8</span>;<br><br>Solution find;<br>vector&lt;<span class="hljs-type">int</span>&gt;result = find.<span class="hljs-built_in">twoSum</span>(nums, target);<br><br><span class="hljs-keyword">if</span> (!result.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;目标值&quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot;是下标为&quot;</span><br>&lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;和&quot;</span> &lt;&lt; result[<span class="hljs-number">1</span>]<br>&lt;&lt; <span class="hljs-string">&quot;对应的值之和&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有两数之和是&quot;</span> &lt;&lt; target &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        hashtable = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> target - num <span class="hljs-keyword">in</span> hashtable:<br>                <span class="hljs-keyword">return</span> [hashtable[target - num], i]<br>            hashtable[nums[i]] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p></blockquote><h3 id="代码展示："><a href="#代码展示：" class="headerlink" title="代码展示："></a>代码展示：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode head; <span class="hljs-comment">// 定义链表头节点</span><br>        ListNode* cur = &amp;head;<span class="hljs-comment">//定义链表首节点</span><br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义单个节点的和数</span><br>        <span class="hljs-keyword">while</span> (l1 || l2 || carry) <span class="hljs-comment">// 有一个不是空节点，或者还有进位，就继续迭代</span><br>        &#123; <br>            sum = carry + (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>); <span class="hljs-comment">// 节点值和进位加在一起</span><br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>); <span class="hljs-comment">// 每个节点保存一个数位</span><br>            carry = sum / <span class="hljs-number">10</span>; <span class="hljs-comment">// 新的进位</span><br>            <span class="hljs-keyword">if</span> (l1) l1 = l1-&gt;next; <span class="hljs-comment">// 下一个节点</span><br>            <span class="hljs-keyword">if</span> (l2) l2 = l2-&gt;next; <span class="hljs-comment">// 下一个节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next; <span class="hljs-comment">// 哨兵节点的下一个节点就是头节点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 遍历链表 l1</span><br><span class="hljs-keyword">while</span> (l1) &#123; <span class="hljs-comment">// 从链表头节点开始向后遍历，直到遇到空节点</span><br>    cout &lt;&lt; l1-&gt;val &lt;&lt; endl; <span class="hljs-comment">// 当前节点值</span><br>    l1 = l1-&gt;next; <span class="hljs-comment">// 准备遍历下一个节点</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/08/31/hello-world/"/>
    <url>/2024/08/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h3 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h3><p>创建新文章：hexo new “我的新文章”</p><p>部署到github：hexo g -d</p><p>常用hexo命令：</p><p>hexo clean &#x2F;&#x2F;清除hexo缓存<br>hexo g     &#x2F;&#x2F;重新生成hexo<br>hexo s     &#x2F;&#x2F;运行本地服务器<br>hexo d     &#x2F;&#x2F;将hexo推送到设置好的服务器上<br>hexo new   xxx &#x2F;&#x2F;新建博文<br>hexo new page xxx &#x2F;&#x2F;新建页面</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
