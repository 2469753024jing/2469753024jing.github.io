<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode</title>
    <link href="/2024/08/31/LeetCode/"/>
    <url>/2024/08/31/LeetCode/</url>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><h3 id="题目介绍："><a href="#题目介绍：" class="headerlink" title="题目介绍："></a>题目介绍：</h3><blockquote><p>输入：nums&#x3D;{2,7,11,15} , target&#x3D;22</p><p>输出：1,3</p><p>解释：因为num[1]+num[3]&#x3D;&#x3D;22 , 所以返回1,3</p></blockquote><h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><h3 id="完整代码展示"><a href="#完整代码展示" class="headerlink" title="完整代码展示"></a>完整代码展示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> target)<br>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)<br>&#123;<br><span class="hljs-keyword">return</span>&#123; i,j &#125;;<br>&#125;<br><br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//问题在于if else这种写法中没有写全，比如只写了if后返回XXX。没写if不成功情况下返回XXX。虽然我们看没问题，但是编译器比较严谨，加上就好了。比如下面代码块行是指失败时候返回空容器。返回一个空容器就没问题了。</span><br>        <span class="hljs-comment">//这两句代码使用了C++11引入的列表初始化语法：它允许你直接在返回语句中初始化一个对象。</span><br>        <span class="hljs-comment">//例如：return&#123;i，j&#125;；中就创建一个临时vector对象，并用i和j作为它的初始化元素。即，在C++11中，当你使用花括号&#123;&#125;包围一系列值时，并且这些值被用于需要特定类型对象的上下文中（比如函数的返回类型），编译器会自动进行类型推导和对象初始化。</span><br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;nums = &#123; <span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">22</span>;<br><br>Solution find;<span class="hljs-comment">//类的对象</span><br>vector&lt;<span class="hljs-type">int</span>&gt;result=find.<span class="hljs-built_in">twoSum</span>(nums, target);<br><br><span class="hljs-keyword">if</span> (!result.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;目标值&quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot;是下标为&quot;</span><br>&lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;和&quot;</span> &lt;&lt; result[<span class="hljs-number">1</span>] <br>&lt;&lt; <span class="hljs-string">&quot;对应的值之和&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有两数之和是&quot;</span> &lt;&lt; target &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br>        <br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h3 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h3><h3 id="完整代码展示-1"><a href="#完整代码展示-1" class="headerlink" title="完整代码展示"></a>完整代码展示</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一"></p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png" alt="过程二"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-comment">//与vector同样unordered_map也是C++标准模板库的一个头文件。</span><br><span class="hljs-comment">//vector定义了一个序列容器,unordered_map定义了一个 关联容器。</span><br><span class="hljs-comment">//本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。</span><br><span class="hljs-comment">//map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> target)<br>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;hashtable;<br>        <span class="hljs-comment">//unorder_map存储的元素是键值对(key-value pairs),其中每一个键都是唯一的，并且映射到一个值。因此unordered_map&lt;int, int&gt;hashtable;创建了一个unorder_map&lt;int,int&gt;类型的关联容器hashtable，用以存储数组nums中的元素值作为键(key),以及这些元素在数组中的索引作为值(value)。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>&#123;<br><span class="hljs-keyword">auto</span> it = hashtable.<span class="hljs-built_in">find</span>(target - nums[i]);<br><span class="hljs-keyword">if</span> (it != hashtable.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">return</span> &#123; it-&gt;second,i &#125;;<br>&#125;<br><span class="hljs-comment">//hashtable[nums[i]] = i;这是一种写法</span><br>            hashtable.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            <span class="hljs-comment">//这行代码是在向一个名为hashtable的unorder_map容器中添加或 更新一个键值对。</span><br>            <span class="hljs-comment">//键：nums[i]，是正在遍历的nums数组中的元素。</span><br>            <span class="hljs-comment">//值：i，是该元素在nums数组中的索引。</span><br>            <span class="hljs-comment">//如果hashtable中不存在键等于nums[i]，那么一个新的键值对将被添加到hashtable中，键为nums[i],值为i。</span><br>            <span class="hljs-comment">//如果hashtable中已经存在一个键等于nums[i]，那么它相关联的值将被更新为当前的i</span><br>&#125;<br><span class="hljs-keyword">return</span>&#123;&#125;;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;nums = &#123; <span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">8</span>;<br><br>Solution find;<br>vector&lt;<span class="hljs-type">int</span>&gt;result = find.<span class="hljs-built_in">twoSum</span>(nums, target);<br><br><span class="hljs-keyword">if</span> (!result.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;目标值&quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot;是下标为&quot;</span><br>&lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;和&quot;</span> &lt;&lt; result[<span class="hljs-number">1</span>]<br>&lt;&lt; <span class="hljs-string">&quot;对应的值之和&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有两数之和是&quot;</span> &lt;&lt; target &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        hashtable = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> target - num <span class="hljs-keyword">in</span> hashtable:<br>                <span class="hljs-keyword">return</span> [hashtable[target - num], i]<br>            hashtable[nums[i]] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p></blockquote><h3 id="代码展示："><a href="#代码展示：" class="headerlink" title="代码展示："></a>代码展示：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ListNode head; <span class="hljs-comment">// 定义链表头节点</span><br>        ListNode* cur = &amp;head;<span class="hljs-comment">//定义链表首节点</span><br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义单个节点的和数</span><br>        <span class="hljs-keyword">while</span> (l1 || l2 || carry) <span class="hljs-comment">// 有一个不是空节点，或者还有进位，就继续迭代</span><br>        &#123; <br>            sum = carry + (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>); <span class="hljs-comment">// 节点值和进位加在一起</span><br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>); <span class="hljs-comment">// 每个节点保存一个数位</span><br>            carry = sum / <span class="hljs-number">10</span>; <span class="hljs-comment">// 新的进位</span><br>            <span class="hljs-keyword">if</span> (l1) l1 = l1-&gt;next; <span class="hljs-comment">// 下一个节点</span><br>            <span class="hljs-keyword">if</span> (l2) l2 = l2-&gt;next; <span class="hljs-comment">// 下一个节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next; <span class="hljs-comment">// 哨兵节点的下一个节点就是头节点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 遍历链表 l1</span><br><span class="hljs-keyword">while</span> (l1) &#123; <span class="hljs-comment">// 从链表头节点开始向后遍历，直到遇到空节点</span><br>    cout &lt;&lt; l1-&gt;val &lt;&lt; endl; <span class="hljs-comment">// 当前节点值</span><br>    l1 = l1-&gt;next; <span class="hljs-comment">// 准备遍历下一个节点</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur = head = ListNode()  <span class="hljs-comment"># 头节点</span><br>        carry = <span class="hljs-number">0</span>  <span class="hljs-comment"># 进位</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:  <span class="hljs-comment"># 有一个不是空节点，或者还有进位，就继续迭代</span><br>            s = carry + (l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + (l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)  <span class="hljs-comment"># 节点值和进位加在一起</span><br>            cur.<span class="hljs-built_in">next</span> = ListNode(s % <span class="hljs-number">10</span>)  <span class="hljs-comment"># 每个节点保存一个数位</span><br>            carry = s // <span class="hljs-number">10</span>  <span class="hljs-comment"># 新的进位</span><br>            cur = cur.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>            <span class="hljs-keyword">if</span> l1: l1 = l1.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>            <span class="hljs-keyword">if</span> l2: l2 = l2.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 哨兵节点的下一个节点就是头节点</span><br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><blockquote><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>示例 ：</p><p><strong>输入：</strong>s &#x3D; “([])”</p><p><strong>输出：</strong>true</p></blockquote><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>​判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>​我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>​当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>​在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p><h3 id="代码展示：-1"><a href="#代码展示：-1" class="headerlink" title="代码展示："></a>代码展示：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>      stack&lt;<span class="hljs-type">int</span>&gt; st;<span class="hljs-comment">//定义一个栈</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>          <span class="hljs-comment">//C++中 使用 for(char c:s) 遍历字符串相当于 for( int i = 0; i &lt; s.length(); i++)，使用它时会复制一个s字符串再进行遍历操作</span><br>          <span class="hljs-comment">//而使用 for (char&amp; c : s) 时直接引用原字符串进行遍历操作。由于复制一个字符串花费了大量的时间，所以第二种解法要快于第一种解法。</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span> || s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) st.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//入栈</span><br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>          <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//栈空，但是栈外还有右括号无法匹配</span><br>          <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; s[st.<span class="hljs-built_in">top</span>()] != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; s[st.<span class="hljs-built_in">top</span>()] != <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; s[st.<span class="hljs-built_in">top</span>()] != <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          st.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//删除已经匹配过的栈顶元素</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//st.empty()代表：若栈为空，返回true，若栈不为空，返回false</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p></blockquote><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>​根据题目描述,链表l1是递增的，因此容易想到使用双指针l1和l2遍历两链表，根据l1.val和l2.val的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。</p><p>​引入伪头节点： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点，将各节点添加至 dum 之后。</p><p><img src="https://pic.leetcode-cn.com/e4c8c97883da50d81498fd1f1e6cdd575429bd65f9f2babb00dc2b709f7ad8b2-Picture1.png" alt="Picture1.png"></p><h3 id="代码展示：-2"><a href="#代码展示：-2" class="headerlink" title="代码展示："></a>代码展示：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* cur = dum;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//获取俩链表当前值小的结点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) <br>            &#123;<br>                cur-&gt;next = list1;<span class="hljs-comment">//cur 指向值小的结点</span><br>                list1 = list1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                cur-&gt;next = list2;<span class="hljs-comment">//cur 指向值小的结点</span><br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<span class="hljs-comment">////cur 后移</span><br>        &#125;<br>        cur-&gt;next = list1 != <span class="hljs-literal">nullptr</span> ? list1 : list2;<span class="hljs-comment">//循环结束，list1 和 list2 其中有一个为空，但不知道是哪个</span><br>        <span class="hljs-keyword">return</span> dum-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur = dum = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>            <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>                cur.<span class="hljs-built_in">next</span>, list1 = list1, list1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                cur.<span class="hljs-built_in">next</span>, list2 = list2, list2.<span class="hljs-built_in">next</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">else</span> list2<br>        <span class="hljs-keyword">return</span> dum.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/08/31/hello-world/"/>
    <url>/2024/08/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h3 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h3><p>创建新文章：hexo new “我的新文章”</p><p>部署到github：hexo g -d</p><p>常用hexo命令：</p><p>hexo clean &#x2F;&#x2F;清除hexo缓存<br>hexo g     &#x2F;&#x2F;重新生成hexo<br>hexo s     &#x2F;&#x2F;运行本地服务器<br>hexo d     &#x2F;&#x2F;将hexo推送到设置好的服务器上<br>hexo new   xxx &#x2F;&#x2F;新建博文<br>hexo new page xxx &#x2F;&#x2F;新建页面</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
