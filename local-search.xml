<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/10/0005.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/09/10/0005.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://programmercarl.com/other/xunlianying.html" target="_blank">  <img src="../pics/训练营.png" width="1000"/></a><p align="center"><strong><a href="https://mp.weixin.qq.com/s/tqCxrMEU-ajQumL1i8im9A">参与本项目</a>，贡献其他语言版本的代码，拥抱开源，让更多学习算法的小伙伴们收益！</strong></p><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">力扣题目链接</a></p><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><ul><li>输入：s &#x3D; “babad”</li><li>输出：”bab”</li><li>解释：”aba” 同样是符合题意的答案。</li></ul><p>示例 2：</p><ul><li>输入：s &#x3D; “cbbd”</li><li>输出：”bb”</li></ul><p>示例 3：</p><ul><li>输入：s &#x3D; “a”</li><li>输出：”a”</li></ul><p>示例 4：</p><ul><li>输入：s &#x3D; “ac”</li><li>输出：”a”</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题和<a href="https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html">647.回文子串</a> 差不多是一样的，但647.回文子串更基本一点，建议可以先做647.回文子串</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>两层for循环，遍历区间起始位置和终止位置，然后判断这个区间是不是回文。</p><p>时间复杂度：O(n^3)</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</p><ol start="2"><li>确定递推公式</li></ol><p>在确定递推公式时，就要分析如下几种情况。</p><p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li></ul><p>以上三种情况分析完了，那么递归公式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里我没有列出当s[i]与s[j]不相等的时候，因为在下面dp[i][j]初始化的时候，就初始为false。</p><p>在得到[i,j]区间是否是回文子串的时候，直接保存最长回文子串的左边界和右边界，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>        dp[i][j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxlenth) &#123;<br>    maxlenth = j - i + <span class="hljs-number">1</span>;<br>    left = i;<br>    right = j;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>dp数组如何初始化</li></ol><p>dp[i][j]可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。</p><p>所以dp[i][j]初始化为false。</p><ol start="4"><li>确定遍历顺序</li></ol><p>遍历顺序可有有点讲究了。</p><p>首先从递推公式中可以看出，情况三是根据dp[i + 1][j - 1]是否为true，在对dp[i][j]进行赋值true的。</p><p>dp[i + 1][j - 1] 在 dp[i][j]的左下角，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210121171032473.jpg" alt="647.回文子串"></p><p>如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1][j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。</p><p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的</strong>。</p><p>有的代码实现是优先遍历列，然后遍历行，其实也是一个道理，都是为了保证dp[i + 1][j - 1]都是经过计算的。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 注意遍历顺序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>            <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxlenth) &#123;<br>            maxlenth = j - i + <span class="hljs-number">1</span>;<br>            left = i;<br>            right = j;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>举例，输入：”aaa”，dp[i][j]状态如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210121171059951.jpg" alt="647.回文子串1"></p><p><strong>注意因为dp[i][j]的定义，所以j一定是大于等于i的，那么在填充dp[i][j]的时候一定是只填充右上半部分</strong>。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">//定义二维vector</span><br>        <span class="hljs-comment">//例如 vector &lt;vector&lt;int&gt; &gt;array</span><br>        <span class="hljs-comment">//array用来保存一个二维数组，array的每个元素都是vector&lt;int&gt;类型</span><br>        <span class="hljs-type">int</span> maxlenth = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 情况一 和 情况二</span><br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 情况三</span><br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxlenth) &#123;<br>                    maxlenth = j - i + <span class="hljs-number">1</span>;<br>                    left = i;<br>                    right = j;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(left, right - left + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上代码是为了凸显情况一二三，当然是可以简洁一下的，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> maxlenth = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxlenth) &#123;<br>                    maxlenth = j - i + <span class="hljs-number">1</span>;<br>                    left = i;<br>                    right = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(left, maxlenth);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n^2)</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>动态规划的空间复杂度是偏高的，我们再看一下双指针法。</p><p>首先确定回文串，就是找中心然后想两边扩散看是不是对称的就可以了。</p><p><strong>在遍历中心点的时候，要注意中心点有两种情况</strong>。</p><p>一个元素可以作为中心点，两个元素也可以作为中心点。</p><p>那么有的同学问了，三个元素还可以做中心点呢。其实三个元素就可以由一个元素左右添加元素得到，四个元素则可以由两个元素左右添加元素得到。</p><p>所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。</p><p><strong>这两种情况可以放在一起计算，但分别计算思路更清晰，我倾向于分别计算</strong>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-built_in">extend</span>(s, i, i, s.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 以i为中心</span><br>            <span class="hljs-built_in">extend</span>(s, i, i + <span class="hljs-number">1</span>, s.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 以i和i+1为中心</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(left, maxLength);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j]) &#123;<br>            <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &gt; maxLength) &#123;<br>                left = i;<br>                right = j;<br>                maxLength = j - i + <span class="hljs-number">1</span>;<br>            &#125;<br>            i--;<br>            j++;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(1)</li></ul><h1 id="其他语言版本"><a href="#其他语言版本" class="headerlink" title="其他语言版本"></a>其他语言版本</h1><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 双指针 动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span> || s.length() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[][] palindrome = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            palindrome[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; L &lt;= s.length(); L++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + L - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (j &gt;= s.length()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;<br>                    palindrome[i][j] = <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) &#123;<br>                        palindrome[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        palindrome[i][j] = palindrome[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (palindrome[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; length) &#123;<br>                    length = j - i + <span class="hljs-number">1</span>;<br>                    index = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(index, index + length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 双指针 中心扩散法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 分两种情况：即一个元素作为中心点，两个元素作为中心点</span><br>            s1 = extend(s, i, i);  <span class="hljs-comment">// 情况1</span><br>            res = s1.length() &gt; res.length() ? s1 : res;<br>            s2 = extend(s, i, i + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 情况2</span><br>            res = s2.length() &gt; res.length() ? s2 : res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;  <span class="hljs-comment">// 返回最长的</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">extend</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end))&#123;<br>            tmp = s.substring(start, end + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Java中substring是左闭右开的，所以要+1</span><br>            <span class="hljs-comment">// 向两边扩散</span><br>            start--;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        dp = [[<span class="hljs-literal">False</span>] * <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        maxlenth = <span class="hljs-number">0</span><br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> s[j] == s[i]:<br>                    <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]:<br>                        dp[i][j] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">and</span> j - i + <span class="hljs-number">1</span> &gt; maxlenth:<br>                    maxlenth = j - i + <span class="hljs-number">1</span><br>                    left = i<br>                    right = j<br>        <span class="hljs-keyword">return</span> s[left:right + <span class="hljs-number">1</span>]<br><br></code></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_point</span>(<span class="hljs-params">i, j, s</span>):<br>            <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[i] == s[j]:<br>                i -= <span class="hljs-number">1</span><br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>, j<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">start, end, left, right</span>):<br>            <span class="hljs-keyword">if</span> right - left &gt; end - start:<br>                <span class="hljs-keyword">return</span> left, right<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> start, end<br><br>        start = <span class="hljs-number">0</span><br>        end = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            left, right = find_point(i, i, s)<br>            start, end = compare(start, end, left, right)<br><br>            left, right = find_point(i, i + <span class="hljs-number">1</span>, s)<br>            start, end = compare(start, end, left, right)<br>        <span class="hljs-keyword">return</span> s[start:end]<br><br></code></pre></td></tr></table></figure><p>Go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    maxLen := <span class="hljs-number">0</span><br>    left := <span class="hljs-number">0</span><br>    length := <span class="hljs-number">0</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s))<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; <span class="hljs-built_in">len</span>(s); j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j]&#123;<br>                <span class="hljs-keyword">if</span> j-i &lt;= <span class="hljs-number">1</span>&#123; <span class="hljs-comment">// 情况一和情况二</span><br>                    length = j-i<br>                    dp[i][j]=<span class="hljs-literal">true</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]&#123; <span class="hljs-comment">// 情况三</span><br>                    length = j-i<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> length &gt; maxLen &#123;<br>            maxLen = length<br>            left = i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s[left: left+maxLen+<span class="hljs-number">1</span>]<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>JavaScript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//动态规划解法</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">const</span> len = s.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false</span><br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">false</span>));<br>    <span class="hljs-comment">// left起始位置  maxlenth回文串长度</span><br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, maxlenth = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; len; j++)&#123;<br>            <span class="hljs-comment">// 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串 j - i == 0</span><br>            <span class="hljs-comment">// 情况二：下标i 与 j相差为1，例如aa，也是文子串 j - i == 1</span><br>            <span class="hljs-comment">// 情况一和情况二 可以合并为 j - i &lt;= 1</span><br>            <span class="hljs-comment">// 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]===true</span><br>            <span class="hljs-keyword">if</span>(s[i] === s[j] &amp;&amp; (j - i &lt;= <span class="hljs-number">1</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]))&#123;<br>                dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置</span><br>            <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxlenth) &#123;<br>                maxlenth = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 回文串长度</span><br>                left = i; <span class="hljs-comment">// 起始位置</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substr</span>(left, maxlenth); <span class="hljs-comment">// 找到子串</span><br>&#125;;<br><br><span class="hljs-comment">//双指针</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">extend</span> = (<span class="hljs-params">s, i, j, n</span>) =&gt; &#123;<span class="hljs-comment">// s为字符串 i,j为双指针 n为字符串长度</span><br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] === s[j])&#123;<br>            <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt; maxLength)&#123;<br>                left = i; <span class="hljs-comment">// 更新开始位置</span><br>                right = j; <span class="hljs-comment">// 更新结尾位置</span><br>                maxLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新子串最大长度</span><br>            &#125;<br>            <span class="hljs-comment">// 指针移动</span><br>            i--;<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-title function_">extend</span>(s, i, i, s.<span class="hljs-property">length</span>); <span class="hljs-comment">// 以i为中心</span><br>        <span class="hljs-title function_">extend</span>(s, i, i + <span class="hljs-number">1</span>, s.<span class="hljs-property">length</span>); <span class="hljs-comment">// 以i和i+1为中心</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substr</span>(left, maxLength);<br>&#125;;<br><br><span class="hljs-comment">//Manacher算法</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">const</span> len = s.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>, index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//Manacher算法,利用回文对称的性质，根据i在上一个回文中心的臂长里的位置去判断i的回文性</span><br>    <span class="hljs-comment">//需要知道上一个回文中心，以及其臂长</span><br>    <span class="hljs-keyword">let</span> center = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//注意这里使用了maxRight的而不是真实的臂长length,因为之后需要判断i在臂长的什么位置</span><br>    <span class="hljs-comment">//如果这里臂长用了length,之后还要 计算i - center 去和 length比较，太繁琐</span><br>    <span class="hljs-keyword">let</span> maxRight = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//考虑到回文串的长度是偶数的情况,所以这里预处理一下字符串,每个字符间插入特殊字符,把可能性都化为奇数</span><br>    <span class="hljs-comment">//这个处理把回文串长度的可能性都化为了奇数</span><br>    <span class="hljs-comment">//#c#b#b#a#</span><br>    <span class="hljs-comment">//#c#b#a#b#d#</span><br>    <span class="hljs-keyword">let</span> ss = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++)&#123;<br>        ss += <span class="hljs-string">&quot;#&quot;</span>+s[i];<br>    &#125;<br>    ss += <span class="hljs-string">&quot;#&quot;</span>;<br>    <span class="hljs-comment">//需要维护一个每个位置臂长的信息数组positionLength</span><br>    <span class="hljs-keyword">const</span> pl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(ss.<span class="hljs-property">length</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//这里需要注意参考的是i关于center对称的点i&#x27;的回文性</span><br>    <span class="hljs-comment">//i&#x27; = 2*center - i;</span><br>    <span class="hljs-comment">//所以列下情况:</span><br>    <span class="hljs-comment">//1.i&gt;maxRight,找不到i&#x27;,无法参考，自己算自己的</span><br>    <span class="hljs-comment">//2.i&lt;=maxRight:</span><br>    <span class="hljs-comment">//2.1 i&lt;maxRight-pl[i&#x27;],pl[i&#x27;]的臂长没有超过center的臂长,根据对称性,pl[i] = pl[i&#x27;]</span><br>    <span class="hljs-comment">//2.2 i=maxRight-pl[i&#x27;],pl[i&#x27;]的臂长刚好等于center的臂长,根据对称性,pl[i] &gt;= pl[i‘],大多少需要尝试扩散</span><br>    <span class="hljs-comment">//2.3 i&gt;maxRight-pl[i&#x27;],pl[i&#x27;]的臂长超过了center的臂长,根据对称性,i中心扩散到MaxRight处,</span><br>    <span class="hljs-comment">// s[2*i-maxRight] !== s[MaxRight]必不相等，所以pl[i] = maxRight-i;</span><br>    <span class="hljs-comment">//总结就是pl[i] = Math.min(maxRight-i,pl[i&#x27;]);提示i&lt;maxRight-pl[i&#x27;] 也可写成 pl[i&#x27;]&lt;maxRight-i</span><br>    <span class="hljs-comment">//0没有意义,从1开始计算</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; ss.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt;= maxRight)&#123;<span class="hljs-comment">//可以参考之前的</span><br>            pl[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(maxRight - i, pl[<span class="hljs-number">2</span> * center - i]);<br>            <span class="hljs-comment">//尝试中心扩散</span><br>        &#125;<br>        <span class="hljs-comment">//注意到i&lt;maxRight时都要尝试中心扩散,所以写else完全无意义,把中心扩散的代码写在下面</span><br>        <span class="hljs-comment">// else&#123;//i不在之前回文中心的臂长范围里,之前的信息就完全无法参考,只能从i中心扩散把，然后去维护maxRight和center的定义</span><br>        <span class="hljs-comment">//尝试中心扩散</span><br>        <span class="hljs-comment">//这里不要动center和maxRight</span><br>        <span class="hljs-comment">// center = i;</span><br>        <span class="hljs-comment">// maxRight = pl[i] + i + 1;</span><br>        <span class="hljs-keyword">let</span> right = pl[i] + i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> left = i - pl[i] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right&lt;ss.<span class="hljs-property">length</span> &amp;&amp; ss[left] === ss[right]) &#123;<br>            right++;<br>            left--;<br>            pl[i]++;<br>        &#125;<br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">if</span>(pl[i] + i &gt; maxRight)&#123;<br>            center = i;<br>            maxRight = pl[i] + i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pl[i] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &gt; maxLength)&#123;<br>            maxLength = pl[i]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            index = i - pl[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ss.<span class="hljs-title function_">substr</span>(index, maxLength).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/#/g</span>,<span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>C：</p><p>动态规划：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化dp数组，全部初始为false</span><br><span class="hljs-type">bool</span> **<span class="hljs-title function_">initDP</span><span class="hljs-params">(<span class="hljs-type">int</span> strLen)</span> &#123;<br>    <span class="hljs-type">bool</span> **dp = (<span class="hljs-type">bool</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">bool</span> *) * strLen);<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; strLen; ++i) &#123;<br>        dp[i] = (<span class="hljs-type">bool</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">bool</span>) * strLen);<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; strLen; ++j)<br>            dp[i][j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp;<br>&#125;<br><br><span class="hljs-type">char</span> * <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span>&#123;<br>    <span class="hljs-comment">//求出字符串长度</span><br>    <span class="hljs-type">int</span> strLen = <span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-comment">//初始化dp数组，元素初始化为false</span><br>    <span class="hljs-type">bool</span> **dp = initDP(strLen);<br>    <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//从下到上，从左到右遍历</span><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span>(i = strLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">for</span>(j = i; j &lt; strLen; ++j) &#123;<br>            <span class="hljs-comment">//若当前i与j所指字符一样</span><br>            <span class="hljs-keyword">if</span>(s[i] == s[j]) &#123;<br>                <span class="hljs-comment">//若i、j指向相邻字符或同一字符，则为回文字符串</span><br>                <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">1</span>)<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//若i+1与j-1所指字符串为回文字符串，则i、j所指字符串为回文字符串</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//若新的字符串的长度大于之前的最大长度，进行更新</span><br>            <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLength) &#123;<br>                maxLength = j - i + <span class="hljs-number">1</span>;<br>                left = i;<br>                right = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//复制回文字符串，并返回</span><br>    <span class="hljs-type">char</span> *ret = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * (maxLength + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">memcpy</span>(ret, s + left, maxLength);<br>    ret[maxLength] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> left, maxLength;<br><span class="hljs-type">void</span> <span class="hljs-title function_">extend</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; size &amp;&amp; str[i] == str[j]) &#123;<br>        <span class="hljs-comment">//若当前子字符串长度大于最长的字符串长度，进行更新</span><br>        <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt; maxLength) &#123;<br>            maxLength = j - i + <span class="hljs-number">1</span>;<br>            left = i;<br>        &#125;<br>        <span class="hljs-comment">//左指针左移，右指针右移。扩大搜索范围</span><br>        ++j, --i;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">char</span> * <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span>&#123;<br>    left = right = maxLength = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> size = <span class="hljs-built_in">strlen</span>(s);<br><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-comment">//长度为单数的子字符串</span><br>        extend(s, i, i, size);<br>        <span class="hljs-comment">//长度为双数的子字符串</span><br>        extend(s, i, i + <span class="hljs-number">1</span>, size);<br>    &#125;<br><br>    <span class="hljs-comment">//复制子字符串</span><br>    <span class="hljs-type">char</span> *subStr = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * (maxLength + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">memcpy</span>(subStr, s + left, maxLength);<br>    subStr[maxLength] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> subStr;<br>&#125;<br></code></pre></td></tr></table></figure><p>C#：</p><p>動態規則：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">LongestPalindrome</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>        <span class="hljs-built_in">bool</span>[,] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[s.Length, s.Length];<br>        <span class="hljs-built_in">int</span> maxlenth = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = s.Length<span class="hljs-number">-1</span> ; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = i; j &lt;s.Length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>                    <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 情况一和情况二</span><br>                        dp[i, j] = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( dp[i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span>] )&#123; <span class="hljs-comment">// 情况三</span><br>                        dp[i, j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(dp[i, j] &amp;&amp; j-i+<span class="hljs-number">1</span> &gt; maxlenth)&#123;<br>                    maxlenth = j-i+<span class="hljs-number">1</span>;<br>                    left = i;<br>                    right = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.Substring(left, maxlenth);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>雙指針：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-built_in">int</span> maxlenth = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> right = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">LongestPalindrome</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>         <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s.Length; i++) &#123;<br>            extend(s, i, i, s.Length); <span class="hljs-comment">// 以i為中心</span><br>            extend(s, i, i + <span class="hljs-number">1</span>, s.Length); <span class="hljs-comment">// 以i和i+1為中心</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> s.Substring(left, maxlenth);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extend</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j, <span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j]) &#123;<br>            <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &gt; maxlenth) &#123;<br>                left = i;<br>                right = j;<br>                maxlenth = j - i + <span class="hljs-number">1</span>;<br>            &#125;<br>            i--;<br>            j++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p align="center"><a href="https://programmercarl.com/other/kstar.html" target="_blank">  <img src="../pics/网站星球宣传海报.jpg" width="1000"/></a>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/09/10/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/09/10/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p align="center"><a href="https://programmercarl.com/other/xunlianying.html" target="_blank">  <img src="../pics/训练营.png" width="1000"/></a><p align="center"><strong><a href="https://mp.weixin.qq.com/s/tqCxrMEU-ajQumL1i8im9A">参与本项目</a>，贡献其他语言版本的代码，拥抱开源，让更多学习算法的小伙伴们收益！</strong></p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接</a></p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p><p>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</p><p>所以返回 [0, 1]</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建议看一下我录的这期视频：<a href="https://www.bilibili.com/video/BV1aT41177mK">梦开始的地方，Leetcode：1.两数之和</a>，结合本题解来学习，事半功倍。</p><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p><p>建议大家做这道题目之前，先做一下这两道</p><ul><li><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词</a></li><li><a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集</a></li></ul><p><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词</a> 这道题目是用数组作为哈希表来解决哈希问题，<a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集</a>这道题目是通过set作为哈希表来解决哈希问题。</p><p>首先我在强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。 </p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p><p>那么我们就应该想到使用哈希法了。</p><p>因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。 </p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。</p><p>C++中map，有三种类型：</p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 更多哈希表的理论知识请看<a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！</a>。</p><p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong>  使用其他语言的录友注意了解一下自己所用语言的数据结构就行。</p><p>接下来需要明确两点： </p><ul><li><strong>map用来做什么</strong></li><li><strong>map中key和value分别表示什么</strong></li></ul><p>map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</p><p>接下来是map中key和value分别表示什么。 </p><p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。 </p><p>那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。 </p><p>所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。 </p><p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p><p>过程如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一"> </p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png" alt="过程二"></p><p>C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//循环外要有返回的值</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题其实有四个重点： </p><ul><li>为什么会想到用哈希表 </li><li>哈希表为什么用map </li><li>本题map是用来存什么的 </li><li>map中的key和value用来存什么的</li></ul><p>把这四点想清楚了，本题才算是理解透彻了。</p><p>很多录友把这道题目 通过了，但都没想清楚map是用来做什么的，以至于对代码的理解其实是 一知半解的。 </p><h2 id="其他语言版本"><a href="#其他语言版本" class="headerlink" title="其他语言版本"></a>其他语言版本</h2><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> target - nums[i];   <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>        <span class="hljs-keyword">if</span>(map.containsKey(temp))&#123;<br>            res[<span class="hljs-number">1</span>] = i;<br>            res[<span class="hljs-number">0</span>] = map.get(temp);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        map.put(nums[i], i);    <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        records = <span class="hljs-built_in">dict</span>()<br><br>        <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):  <br>            <span class="hljs-keyword">if</span> target - value <span class="hljs-keyword">in</span> records:   <span class="hljs-comment"># 遍历当前元素，并在map中寻找是否有匹配的key</span><br>                <span class="hljs-keyword">return</span> [records[target- value], index]<br>            records[value] = index    <span class="hljs-comment"># 遍历当前元素，并在map中寻找是否有匹配的key</span><br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>Go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 暴力解法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> k1, _ := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> k2 := k1 + <span class="hljs-number">1</span>; k2 &lt; <span class="hljs-built_in">len</span>(nums); k2++ &#123;<br>            <span class="hljs-keyword">if</span> target == nums[k1] + nums[k2] &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;k1, k2&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用map方式解题，降低时间复杂度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> index, val := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> preIndex, ok := m[target-val]; ok &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;preIndex, index&#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m[val] = index<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Rust</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">two_sum</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">with_capacity</span>(nums.<span class="hljs-title function_ invoke__">len</span>());<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..nums.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(k) = map.<span class="hljs-title function_ invoke__">get</span>(&amp;(target - nums[i])) &#123;<br>                <span class="hljs-keyword">if</span> *k != i &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vec!</span>[*k <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>,  i <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>];<br>                &#125;<br>            &#125;<br>            map.<span class="hljs-title function_ invoke__">insert</span>(nums[i], i);<br>        &#125;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;not found&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>  <span class="hljs-keyword">let</span> hash = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;  <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>    <span class="hljs-keyword">if</span> (hash[target - nums[i]] !== <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-keyword">return</span> [i, hash[target - nums[i]]];<br>    &#125;<br>    hash[nums[i]] = i;   <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> [];<br>&#125;;<br></code></pre></td></tr></table></figure><p>TypeScript：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params"><span class="hljs-attr">nums</span>: <span class="hljs-built_in">number</span>[], <span class="hljs-attr">target</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">helperMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">resArr</span>: <span class="hljs-built_in">number</span>[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, length = nums.<span class="hljs-property">length</span>; i &lt; length; i++) &#123;<br>        index = helperMap.<span class="hljs-title function_">get</span>(target - nums[i]);<br>        <span class="hljs-keyword">if</span> (index !== <span class="hljs-literal">undefined</span>) &#123;<br>            resArr = [i, index];<br>        &#125;<br>        helperMap.<span class="hljs-title function_">set</span>(nums[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> resArr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params"><span class="hljs-keyword">array</span> <span class="hljs-variable">$nums</span>, <span class="hljs-keyword">int</span> <span class="hljs-variable">$target</span></span>): <span class="hljs-title">array</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$map</span> = [];<br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$nums</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$i</span> =&gt; <span class="hljs-variable">$num</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$map</span>[<span class="hljs-variable">$target</span> - <span class="hljs-variable">$num</span>])) &#123;<br>            <span class="hljs-keyword">return</span> [<br>                <span class="hljs-variable">$i</span>,<br>                <span class="hljs-variable">$map</span>[<span class="hljs-variable">$target</span> - <span class="hljs-variable">$num</span>]<br>            ];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$map</span>[<span class="hljs-variable">$num</span>] = <span class="hljs-variable">$i</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [];<br>&#125;<br></code></pre></td></tr></table></figure><p>Swift：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">nums</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">target</span>: <span class="hljs-type">Int</span>) -&gt; [<span class="hljs-type">Int</span>] &#123;<br>    <span class="hljs-comment">// 值: 下标</span><br>    <span class="hljs-keyword">var</span> map <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>: <span class="hljs-type">Int</span>]()<br>    <span class="hljs-keyword">for</span> (i, e) <span class="hljs-keyword">in</span> nums.enumerated() &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> v <span class="hljs-operator">=</span> map[target <span class="hljs-operator">-</span> e] &#123;<br>            <span class="hljs-keyword">return</span> [v, i]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map[e] <span class="hljs-operator">=</span> i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<br>&#125;<br></code></pre></td></tr></table></figure><p>Scala:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-comment">// 导入包</span><br>  <span class="hljs-keyword">import</span> scala.collection.mutable<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span></span>(nums: <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>], target: <span class="hljs-type">Int</span>): <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>] = &#123;<br>    <span class="hljs-comment">// key存储值，value存储下标</span><br>    <span class="hljs-keyword">val</span> map = <span class="hljs-keyword">new</span> mutable.<span class="hljs-type">HashMap</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>]()<br>    <span class="hljs-keyword">for</span> (i &lt;- nums.indices) &#123;<br>      <span class="hljs-keyword">val</span> tmp = target - nums(i) <span class="hljs-comment">// 计算差值</span><br>      <span class="hljs-comment">// 如果这个差值存在于map，则说明找到了结果</span><br>      <span class="hljs-keyword">if</span> (map.contains(tmp)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Array</span>(map.get(tmp).get, i)<br>      &#125;<br>      <span class="hljs-comment">// 如果不包含把当前值与其下标放到map</span><br>      map.put(nums(i), i)<br>    &#125;<br>    <span class="hljs-comment">// 如果没有找到直接返回一个空的数组，return关键字可以省略</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">2</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C#:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">TwoSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target</span>)</span> &#123;<br>        Dictionary&lt;<span class="hljs-built_in">int</span> ,<span class="hljs-built_in">int</span>&gt; dic= <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.Length;i++)&#123;<br>            <span class="hljs-built_in">int</span> imp= target-nums[i];<br>            <span class="hljs-keyword">if</span>(dic.ContainsKey(imp)&amp;&amp;dic[imp]!=i)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;i, dic[imp]&#125;;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!dic.ContainsKey(nums[i]))&#123;<br>                dic.Add(nums[i],i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dart:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; twoSum(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; nums, <span class="hljs-built_in">int</span> target) &#123;  <br>    <span class="hljs-keyword">var</span> tmp = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">var</span> rest = target - nums[i];<br>        <span class="hljs-keyword">if</span>(tmp.contains(rest))&#123;<br>            <span class="hljs-keyword">return</span> [tmp.indexOf(rest), i];<br>        &#125;<br>        tmp.add(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span> , <span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// leetcode 支持 ut_hash 函式庫</span><br><br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>     <span class="hljs-type">int</span> key;<br>     <span class="hljs-type">int</span> value;<br>     UT_hash_handle hh; <span class="hljs-comment">// make this structure hashable</span><br> &#125; <span class="hljs-built_in">map</span>;<br><br><span class="hljs-built_in">map</span>* hashMap = <span class="hljs-literal">NULL</span>;<br><br> <span class="hljs-type">void</span> <span class="hljs-title function_">hashMapAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span>&#123;<br>     <span class="hljs-built_in">map</span>* s;<br>     <span class="hljs-comment">// key already in the hash?</span><br>     HASH_FIND_INT(hashMap, &amp;key, s);<br>     <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">NULL</span>)&#123;<br>         s = (<span class="hljs-built_in">map</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">map</span>));<br>         s -&gt; key = key;<br>         HASH_ADD_INT(hashMap, key, s);<br>     &#125;<br>     s -&gt; value = value;<br> &#125;<br><br><span class="hljs-built_in">map</span>* <span class="hljs-title function_">hashMapFind</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>     <span class="hljs-built_in">map</span>* s;<br>     <span class="hljs-comment">// *s: output pointer</span><br>     HASH_FIND_INT(hashMap, &amp;key, s);   <br>     <span class="hljs-keyword">return</span> s;<br> &#125;<br><br> <span class="hljs-type">void</span> <span class="hljs-title function_">hashMapCleanup</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-built_in">map</span>* cur, *tmp;<br>     HASH_ITER(hh, hashMap, cur, tmp)&#123;<br>         HASH_DEL(hashMap, cur);<br>         <span class="hljs-built_in">free</span>(cur);<br>     &#125;<br> &#125;<br><br> <span class="hljs-type">void</span> <span class="hljs-title function_">hashPrint</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-built_in">map</span>* s;<br>     <span class="hljs-keyword">for</span>(s = hashMap; s != <span class="hljs-literal">NULL</span>; s=(<span class="hljs-built_in">map</span>*)(s -&gt; hh.next))&#123;<br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key %d, value %d\n&quot;</span>, s -&gt; key, s -&gt; value);<br>     &#125;<br> &#125;<br><br> <br><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>&#123;<br>    <span class="hljs-type">int</span> i, *ans;<br>    <span class="hljs-comment">// hash find result</span><br>    <span class="hljs-built_in">map</span>* hashMapRes; <br>    hashMap = <span class="hljs-literal">NULL</span>;<br>    ans = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numsSize; i++)&#123;<br>        <span class="hljs-comment">// key 代表 nums[i] 的值，value 代表所在 index;</span><br>        hashMapAdd(nums[i], i);<br>    &#125;<br><br>    hashPrint();<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numsSize; i++)&#123;<br>        hashMapRes = hashMapFind(target - nums[i]);<br>        <span class="hljs-keyword">if</span>(hashMapRes &amp;&amp; hashMapRes -&gt; value != i)&#123;<br>            ans[<span class="hljs-number">0</span>] = i;<br>            ans[<span class="hljs-number">1</span>] = hashMapRes -&gt; value ;<br>            *returnSize = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>    <br>    hashMapCleanup();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p align="center"><a href="https://programmercarl.com/other/kstar.html" target="_blank">  <img src="../pics/网站星球宣传海报.jpg" width="1000"/></a>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode</title>
    <link href="/2024/08/31/LeetCode/"/>
    <url>/2024/08/31/LeetCode/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><blockquote><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接</a></p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p><p>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</p><p>所以返回 [0, 1]</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建议看一下我录的这期视频：<a href="https://www.bilibili.com/video/BV1aT41177mK">梦开始的地方，Leetcode：1.两数之和</a>，结合本题解来学习，事半功倍。</p><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p><p>建议大家做这道题目之前，先做一下这两道</p><ul><li><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词</a></li><li><a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集</a></li></ul><p><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html">242. 有效的字母异位词</a> 这道题目是用数组作为哈希表来解决哈希问题，<a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html">349. 两个数组的交集</a>这道题目是通过set作为哈希表来解决哈希问题。</p><p>首先我在强调一下 <strong>什么时候使用哈希法</strong>，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p><p>本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。</p><p>那么我们就应该想到使用哈希法了。</p><p>因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。</li></ul><p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。</p><p>C++中map，有三种类型：</p><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 更多哈希表的理论知识请看<a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于哈希表，你该了解这些！</a>。</p><p><strong>这道题目中并不需要key有序，选择**<strong>std</strong></strong>::unordered_map 效率更高！** 使用其他语言的录友注意了解一下自己所用语言的数据结构就行。</p><p>接下来需要明确两点：</p><ul><li><strong>map用来做什么</strong></li><li><strong>map中key和value分别表示什么</strong></li></ul><p>map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）</p><p>接下来是map中key和value分别表示什么。</p><p>这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。</p><p>那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。</p><p>所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</p><p>在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。</p><p>过程如下：</p><p><img src="https://wcnlel7vrqnz.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWExZmY0NGVmMmMwNDUwZjIwZGIyNTcyYmI3ZjE1ZTZfQzdXV0pUY2ljUE5iS3U0d05QTTJMbXdpVVBYZHJveXNfVG9rZW46VjRxTWJ2bUhPb1FLVUV4MXBxSWNjNTRFbjliXzE3MjU2MzkzNDM6MTcyNTY0Mjk0M19WNA" alt="img"></p><p><img src="https://wcnlel7vrqnz.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM1NTEzYjYwZGJkM2NmZjk0YzJiNGYzYmVmZDIxZThfYUFWUk9SZDczcDlHZmQ2dGpSbXBOdllUVWdkeHhUQ3hfVG9rZW46VXUwamJiYUE5b0lIOVN4QmVJRmNHdDF2bkE4XzE3MjU2MzkzNDM6MTcyNTY0Mjk0M19WNA" alt="img"></p><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//循环外要有返回的值!</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本题其实有四个重点：</p><ul><li>为什么会想到用哈希表</li><li>哈希表为什么用map</li><li>本题map是用来存什么的</li><li>map中的key和value用来存什么的</li></ul><p>把这四点想清楚了，本题才算是理解透彻了。</p><p>自己编写的完整代码如下：</p><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> target)<br>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] + nums[j] == target)<br>&#123;<br><span class="hljs-keyword">return</span>&#123; i,j &#125;;<br>&#125;<br><br><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//问题在于if else这种写法中没有写全，比如只写了if后返回XXX。没写if不成功情况下返回XXX。虽然我们看没问题，但是编译器比较严谨，加上就好了。比如下面代码块行是指失败时候返回空容器。返回一个空容器就没问题了。</span><br>        <span class="hljs-comment">//这两句代码使用了C++11引入的列表初始化语法：它允许你直接在返回语句中初始化一个对象。</span><br>        <span class="hljs-comment">//例如：return&#123;i，j&#125;；中就创建一个临时vector对象，并用i和j作为它的初始化元素。即，在C++11中，当你使用花括号&#123;&#125;包围一系列值时，并且这些值被用于需要特定类型对象的上下文中（比如函数的返回类型），编译器会自动进行类型推导和对象初始化。</span><br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;nums = &#123; <span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">22</span>;<br><br>Solution find;<span class="hljs-comment">//类的对象</span><br>vector&lt;<span class="hljs-type">int</span>&gt;result=find.<span class="hljs-built_in">twoSum</span>(nums, target);<br><br><span class="hljs-keyword">if</span> (!result.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;目标值&quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot;是下标为&quot;</span><br>&lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;和&quot;</span> &lt;&lt; result[<span class="hljs-number">1</span>] <br>&lt;&lt; <span class="hljs-string">&quot;对应的值之和&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有两数之和是&quot;</span> &lt;&lt; target &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br>        <br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-comment">//与vector同样unordered_map也是C++标准模板库的一个头文件。</span><br><span class="hljs-comment">//vector定义了一个序列容器,unordered_map定义了一个 关联容器。</span><br><span class="hljs-comment">//本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。</span><br><span class="hljs-comment">//map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp;nums, <span class="hljs-type">int</span> target)<br>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;hashtable;<br>        <span class="hljs-comment">//unorder_map存储的元素是键值对(key-value pairs),其中每一个键都是唯一的，并且映射到一个值。因此unordered_map&lt;int, int&gt;hashtable;创建了一个unorder_map&lt;int,int&gt;类型的关联容器hashtable，用以存储数组nums中的元素值作为键(key),以及这些元素在数组中的索引作为值(value)。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>&#123;<br><span class="hljs-keyword">auto</span> it = hashtable.<span class="hljs-built_in">find</span>(target - nums[i]);<br><span class="hljs-keyword">if</span> (it != hashtable.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">return</span> &#123; it-&gt;second,i &#125;;<br>&#125;<br><span class="hljs-comment">//hashtable[nums[i]] = i;这是一种写法</span><br>            hashtable.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            <span class="hljs-comment">//这行代码是在向一个名为hashtable的unorder_map容器中添加或 更新一个键值对。</span><br>            <span class="hljs-comment">//键：nums[i]，是正在遍历的nums数组中的元素。</span><br>            <span class="hljs-comment">//值：i，是该元素在nums数组中的索引。</span><br>            <span class="hljs-comment">//如果hashtable中不存在键等于nums[i]，那么一个新的键值对将被添加到hashtable中，键为nums[i],值为i。</span><br>            <span class="hljs-comment">//如果hashtable中已经存在一个键等于nums[i]，那么它相关联的值将被更新为当前的i</span><br>&#125;<br><span class="hljs-keyword">return</span>&#123;&#125;;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;nums = &#123; <span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">8</span>;<br><br>Solution find;<br>vector&lt;<span class="hljs-type">int</span>&gt;result = find.<span class="hljs-built_in">twoSum</span>(nums, target);<br><br><span class="hljs-keyword">if</span> (!result.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;目标值&quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot;是下标为&quot;</span><br>&lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;和&quot;</span> &lt;&lt; result[<span class="hljs-number">1</span>]<br>&lt;&lt; <span class="hljs-string">&quot;对应的值之和&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有两数之和是&quot;</span> &lt;&lt; target &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        hashtable = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> target - num <span class="hljs-keyword">in</span> hashtable:<br>                <span class="hljs-keyword">return</span> [hashtable[target - num], i]<br>            hashtable[nums[i]] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p></blockquote><h2 id="代码展示："><a href="#代码展示：" class="headerlink" title="代码展示："></a>代码展示：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ListNode head; <span class="hljs-comment">// 定义链表头节点</span><br>        ListNode* cur = &amp;head;<span class="hljs-comment">//定义链表首节点</span><br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义单个节点的和数</span><br>        <span class="hljs-keyword">while</span> (l1 || l2 || carry) <span class="hljs-comment">// 有一个不是空节点，或者还有进位，就继续迭代</span><br>        &#123; <br>            sum = carry + (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>); <span class="hljs-comment">// 节点值和进位加在一起</span><br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>); <span class="hljs-comment">// 每个节点保存一个数位</span><br>            carry = sum / <span class="hljs-number">10</span>; <span class="hljs-comment">// 新的进位</span><br>            <span class="hljs-keyword">if</span> (l1) l1 = l1-&gt;next; <span class="hljs-comment">// 下一个节点</span><br>            <span class="hljs-keyword">if</span> (l2) l2 = l2-&gt;next; <span class="hljs-comment">// 下一个节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> head.next; <span class="hljs-comment">// 哨兵节点的下一个节点就是头节点</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 遍历链表 l1</span><br><span class="hljs-keyword">while</span> (l1) &#123; <span class="hljs-comment">// 从链表头节点开始向后遍历，直到遇到空节点</span><br>    cout &lt;&lt; l1-&gt;val &lt;&lt; endl; <span class="hljs-comment">// 当前节点值</span><br>    l1 = l1-&gt;next; <span class="hljs-comment">// 准备遍历下一个节点</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur = head = ListNode()  <span class="hljs-comment"># 头节点</span><br>        carry = <span class="hljs-number">0</span>  <span class="hljs-comment"># 进位</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:  <span class="hljs-comment"># 有一个不是空节点，或者还有进位，就继续迭代</span><br>            s = carry + (l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + (l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)  <span class="hljs-comment"># 节点值和进位加在一起</span><br>            cur.<span class="hljs-built_in">next</span> = ListNode(s % <span class="hljs-number">10</span>)  <span class="hljs-comment"># 每个节点保存一个数位</span><br>            carry = s // <span class="hljs-number">10</span>  <span class="hljs-comment"># 新的进位</span><br>            cur = cur.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>            <span class="hljs-keyword">if</span> l1: l1 = l1.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>            <span class="hljs-keyword">if</span> l2: l2 = l2.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 下一个节点</span><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span>  <span class="hljs-comment"># 哨兵节点的下一个节点就是头节点</span><br></code></pre></td></tr></table></figure><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><blockquote><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p>示例 ：</p><p><strong>输入：</strong>s &#x3D; “([])”</p><p><strong>输出：</strong>true</p></blockquote><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>​判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>​我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>​当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>​在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p><h2 id="代码展示：-1"><a href="#代码展示：-1" class="headerlink" title="代码展示："></a>代码展示：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>      stack&lt;<span class="hljs-type">int</span>&gt; st;<span class="hljs-comment">//定义一个栈</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>          <span class="hljs-comment">//C++中 使用 for(char c:s) 遍历字符串相当于 for( int i = 0; i &lt; s.length(); i++)，使用它时会复制一个s字符串再进行遍历操作</span><br>          <span class="hljs-comment">//而使用 for (char&amp; c : s) 时直接引用原字符串进行遍历操作。由于复制一个字符串花费了大量的时间，所以第二种解法要快于第一种解法。</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span> || s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) st.<span class="hljs-built_in">push</span>(i);<span class="hljs-comment">//入栈</span><br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>          <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//栈空，但是栈外还有右括号无法匹配</span><br>          <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; s[st.<span class="hljs-built_in">top</span>()] != <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; s[st.<span class="hljs-built_in">top</span>()] != <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; s[st.<span class="hljs-built_in">top</span>()] != <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          st.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//删除已经匹配过的栈顶元素</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//st.empty()代表：若栈为空，返回true，若栈不为空，返回false</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p></blockquote><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>​根据题目描述,链表l1是递增的，因此容易想到使用双指针l1和l2遍历两链表，根据l1.val和l2.val的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。</p><p>​引入伪头节点： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点，将各节点添加至 dum 之后。</p><p><img src="https://pic.leetcode-cn.com/e4c8c97883da50d81498fd1f1e6cdd575429bd65f9f2babb00dc2b709f7ad8b2-Picture1.png" alt="Picture1.png"></p><h2 id="代码展示：-2"><a href="#代码展示：-2" class="headerlink" title="代码展示："></a>代码展示：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* cur = dum;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//获取俩链表当前值小的结点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) <br>            &#123;<br>                cur-&gt;next = list1;<span class="hljs-comment">//cur 指向值小的结点</span><br>                list1 = list1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                cur-&gt;next = list2;<span class="hljs-comment">//cur 指向值小的结点</span><br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<span class="hljs-comment">////cur 后移</span><br>        &#125;<br>        cur-&gt;next = list1 != <span class="hljs-literal">nullptr</span> ? list1 : list2;<span class="hljs-comment">//循环结束，list1 和 list2 其中有一个为空，但不知道是哪个</span><br>        <span class="hljs-keyword">return</span> dum-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">self, list1: <span class="hljs-type">Optional</span>[ListNode], list2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur = dum = ListNode(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>            <span class="hljs-keyword">if</span> list1.val &lt; list2.val:<br>                cur.<span class="hljs-built_in">next</span>, list1 = list1, list1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                cur.<span class="hljs-built_in">next</span>, list2 = list2, list2.<span class="hljs-built_in">next</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">else</span> list2<br>        <span class="hljs-keyword">return</span> dum.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/08/31/hello-world/"/>
    <url>/2024/08/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h3 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h3><p>创建新文章：hexo new “我的新文章”</p><p>部署到github：hexo g -d</p><p>常用hexo命令：</p><p>hexo clean &#x2F;&#x2F;清除hexo缓存<br>hexo g     &#x2F;&#x2F;重新生成hexo<br>hexo s     &#x2F;&#x2F;运行本地服务器<br>hexo d     &#x2F;&#x2F;将hexo推送到设置好的服务器上<br>hexo new   xxx &#x2F;&#x2F;新建博文<br>hexo new page xxx &#x2F;&#x2F;新建页面</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
